// Generated by CoffeeScript 1.9.3
(function() {
  var _appendHass, _braceEnd, _braceParser, _elseParser, _indentEnd, _indentParser, hassTools, log, parse, regexs;

  hassTools = require('./hassTools.coffee');

  log = function(a) {
    return console.log(a);
  };

  exports.parser = function(code, filename, style) {
    var ref, res, state, xs;
    style = style || 'indent';
    state = {
      type: 'hass',
      row: 0,
      col: 0,
      text: '',
      path: filename
    };
    xs = [];

    /*
    xs 储存解析后的 数组[]
    state 每行解析的结果
    code 传入的解析数据
    style 书写方式 缩进 或者 大括号
     */
    while (code.length > 0) {
      log(xs);
      ref = parse(xs, state, code, style), xs = ref[0], state = ref[1], code = ref[2], style = ref[3];
    }
    res = parse(xs, state, code, style);
    return res;
  };

  exports.indentParser = function(code, filename) {
    return exports.parser(code, filename, 'indent');
  };

  exports.braceParser = function(code, filename) {
    return exports.parser(code, filename, 'brace');
  };

  regexs = {
    stepOne: /[&!:]/g
  };

  _indentEnd = function(xs, state, code, style) {
    return log("End in indent parse ...");
  };

  _braceEnd = function(xs, state, code, style) {
    return log("End in brace parse ...");
  };

  _elseParser = function(xs, state, code, style) {
    return [xs, state, code.slice(1), style];
  };

  _indentParser = function(xs, state, code, style) {
    return [xs, state, code.slice(1), style];
  };

  _braceParser = function(xs, state, code, style) {
    style = 'brace';
    return [xs, state, code.slice(1), style];
  };

  _appendHass = function(xs, state, code, style) {
    var i, len, str, val;
    state.type = 'hacc';
    state.row += 1;
    state.text = code[0];
    str = code[0].split(' ');
    for (i = 0, len = str.length; i < len; i++) {
      val = str[i];
      if (val === '') {
        state.col += 1;
        continue;
      } else {
        break;
      }
    }
    if (xs.push(state)) {
      return [xs, state, code.slice(1), style];
    }
  };

  parse = function(xs, state, code, style) {
    var args, char, end;
    args = [xs, state, code, style];
    end = code.length === 0;
    char = code[0];
    switch (style) {
      case 'indent':
        if (end) {
          return _indentEnd.apply(null, args);
        } else if (!regexs.stepOne.test(char)) {
          return _appendHass.apply(null, args);
        } else {
          return _elseParser.apply(null, args);
        }
        break;
      case 'brace':
        if (end) {
          _braceEnd.apply(null, args);
        } else {
          _braceParser.apply(null, args);
        }
    }
  };


  /*
  如果没有「&」「!」和「:」，存入 jade 和 sass json对象；
  
  `[^\&\!\:]`
  type写入类型 html css hcss
  row行，col列一空格即一列
  [{
    type: hcss,
     row:  1,
     col: 1,
     text: ".div",//顺便把空格加上
  },
  如果开头有!， 去掉!，写入sass;
  {
    type: css,
     row:  2,
     col: 1,
     text: "div",//顺便把空格加上
  }
  如果该行没有引号（"或'）有:，写入sass;
  {
  type: css,
     row:  3,
     col: 3,
     text: "font:24px",//顺便把空格加上
  }
  如果有&，判断&后面是extends, block, include, text, attr
  
  如果是&extends, 去掉&，找到对应的文件，写入jade;
  如果是&block, 去掉&,写入jade;
  如果是&include 去掉&,找到对应文件，写入jade;
  {type: html,
     row:  1,
     col: 1,
     text: "extends ",//顺便把空格加上}
  
  如果是attr
  查找前对象 type 为非sass col 小余 本行的第一个对象，在找到的前对象的文本后空格或者结束符前面加入（attr后面的内容，并给等号后面,逗号前面和行尾加引号），并且此行不生成的对象。
  
  如果是text
  查找前对象 type为非sass col 小余 本行的第一个对象，在找到的前对象的文本后面加入（text后面的内容）,并且保持插入内容前有空格，并且此行不生成的对象。
  
  foreach 对象，写入sass和jade文件
   */

}).call(this);
