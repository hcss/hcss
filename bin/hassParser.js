// Generated by CoffeeScript 1.9.3
(function() {
  var _, _appendHass, _appendJade, _appendSass, _appendState, _braceEnd, _braceParser, _elseParser, _indentEnd, _indentParser, _preSpaceCount, hassTools, isHcssType, isJadeType, isSassType, log, parse;

  _ = require('underscore');

  _.str = require('underscore.string');

  hassTools = require('./hassTools.coffee');

  log = function(a) {
    return console.log(a);
  };

  exports.parser = function(code, filename, style) {
    var ref, res, state, xs;
    style = style || 'indent';
    state = {
      type: 'hass',
      row: 0,
      col: 0,
      text: '',
      path: filename
    };
    xs = [];

    /*
    xs 储存解析后的 数组[]
    state 每行解析的结果
    code 传入的解析数据
    style 书写方式 缩进 或者 大括号
     */
    while (code.length > 0) {
      ref = parse(xs, state, code, style), xs = ref[0], state = ref[1], code = ref[2], style = ref[3];
    }
    res = parse(xs, state, code, style);
    return res;
  };

  exports.indentParser = function(code, filename) {
    return exports.parser(code, filename, 'indent');
  };

  exports.braceParser = function(code, filename) {
    return exports.parser(code, filename, 'brace');
  };

  isHcssType = function(char) {
    var reg;
    reg = /[&!:]/g;
    return !reg.test(char);
  };

  isJadeType = function(char) {
    var str;
    str = _.str.trim(char);
    return _.str(str).startsWith('&');
  };

  isSassType = function(char) {
    var str;
    str = _.str.trim(char);
    return _.str(str).startsWith('!') || _.str.include(str, ':');
  };

  _preSpaceCount = function(str) {
    var col, i, len, results, strObj, val;
    col = 0;
    strObj = str.split(' ');
    results = [];
    for (i = 0, len = strObj.length; i < len; i++) {
      val = strObj[i];
      if (val === '') {
        col += 1;
        continue;
      } else {
        break;
      }
    }
    return results;
  };

  _indentEnd = function(xs, state, code, style) {
    return log("End in indent parse ...");
  };

  _braceEnd = function(xs, state, code, style) {
    return log("End in brace parse ...");
  };

  _elseParser = function(xs, state, code, style) {
    return [xs, state, code.slice(1), style];
  };

  _appendState = function(type, state, str) {
    state.type = type;
    state.row += 1;
    state.text = str;
    state.col += _preSpaceCount(str);
    return state;
  };

  _appendHass = function(xs, state, code, style) {
    var char;
    char = code[0];
    state = _appendState('hass', state, char);
    if (xs.push(state)) {
      return [xs, state, code.slice(1), style];
    }
  };

  _appendSass = function(xs, state, code, style) {
    var char;
    char = code[0];
    state = _appendState('sass', state, char);
    if (xs.push(state)) {
      return [xs, state, code.slice(1), style];
    }
  };

  _appendJade = function(xs, state, code, style) {
    var char, str, text;
    char = code[0];
    str = _.str.clean(char).split(' ')[0];
    switch (str) {
      case '&extends':
        char = char.replace('&', '');
        break;
      case '&block':
        char = char.replace('&', '');
        break;
      case '&include':
        char = char.replace('&', '');
        break;
      case '&text:':
        text = _.str.trim(char).slice('&text:'.length);
        log("text: " + text);
        return [xs, state, code.slice(1), style];
      case '&attr:':
        text = _.str.trim(char).slice('&text:'.length);
        log("attr: " + text);
        return [xs, state, code.slice(1), style];
      default:
        throw error;
    }
    state = _appendState('jade', state, char);
    if (xs.push(state)) {
      return [xs, state, code.slice(1), style];
    }
  };

  _indentParser = function(xs, state, code, style) {
    var args, char;
    char = code[0];
    args = [xs, state, code, style];
    if (isHcssType(char)) {
      _appendHass.apply(null, args);
    } else if (isJadeType(char)) {
      _appendJade.apply(null, args);
    } else if (isSassType(char)) {
      _appendSass.apply(null, args);
    } else {
      _elseParser.apply(null, args);
    }
    return [xs, state, code.slice(1), style];
  };

  _braceParser = function(xs, state, code, style) {
    style = 'brace';
    return [xs, state, code.slice(1), style];
  };

  parse = function(xs, state, code, style) {
    var args, end;
    log(xs);
    args = [xs, state, code, style];
    end = code.length === 0;
    switch (style) {
      case 'indent':
        if (end) {
          return _indentEnd.apply(null, args);
        } else {
          return _indentParser.apply(null, args);
        }
        break;
      case 'brace':
        if (end) {
          _braceEnd.apply(null, args);
        } else {
          _braceParser.apply(null, args);
        }
    }
  };


  /*
  如果是attr
  查找前对象 type 为非sass col 小余 本行的第一个对象，在找到的前对象的文本后空格或者结束符前面加入（attr后面的内容，并给等号后面,逗号前面和行尾加引号），并且此行不生成的对象。
  
  如果是text
  查找前对象 type为非sass col 小余 本行的第一个对象，在找到的前对象的文本后面加入（text后面的内容）,并且保持插入内容前有空格，并且此行不生成的对象。
  
  foreach 对象，写入sass和jade文件
   */

}).call(this);
